// Generated by jextract

package steamflat4j;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct GSReputation_t {
 *     EResult m_eResult;
 *     uint32 m_unReputationScore;
 *     bool m_bBanned;
 *     uint32 m_unBannedIP;
 *     uint16 m_usBannedPort;
 *     uint64 m_ulBannedGameID;
 *     uint32 m_unBanExpires;
 * }
 * }
 */
public class GSReputation_t {

    GSReputation_t() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        SteamFlat4j.C_INT.withName("m_eResult"),
        SteamFlat4j.C_INT.withName("m_unReputationScore"),
        SteamFlat4j.C_BOOL.withName("m_bBanned"),
        MemoryLayout.paddingLayout(3),
        SteamFlat4j.C_INT.withName("m_unBannedIP"),
        SteamFlat4j.C_SHORT.withName("m_usBannedPort"),
        MemoryLayout.paddingLayout(6),
        SteamFlat4j.C_LONG_LONG.withName("m_ulBannedGameID"),
        SteamFlat4j.C_INT.withName("m_unBanExpires"),
        MemoryLayout.paddingLayout(4)
    ).withName("GSReputation_t");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt m_eResult$LAYOUT = (OfInt)$LAYOUT.select(groupElement("m_eResult"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * EResult m_eResult
     * }
     */
    public static final OfInt m_eResult$layout() {
        return m_eResult$LAYOUT;
    }

    private static final long m_eResult$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * EResult m_eResult
     * }
     */
    public static final long m_eResult$offset() {
        return m_eResult$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * EResult m_eResult
     * }
     */
    public static int m_eResult(MemorySegment struct) {
        return struct.get(m_eResult$LAYOUT, m_eResult$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * EResult m_eResult
     * }
     */
    public static void m_eResult(MemorySegment struct, int fieldValue) {
        struct.set(m_eResult$LAYOUT, m_eResult$OFFSET, fieldValue);
    }

    private static final OfInt m_unReputationScore$LAYOUT = (OfInt)$LAYOUT.select(groupElement("m_unReputationScore"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32 m_unReputationScore
     * }
     */
    public static final OfInt m_unReputationScore$layout() {
        return m_unReputationScore$LAYOUT;
    }

    private static final long m_unReputationScore$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32 m_unReputationScore
     * }
     */
    public static final long m_unReputationScore$offset() {
        return m_unReputationScore$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32 m_unReputationScore
     * }
     */
    public static int m_unReputationScore(MemorySegment struct) {
        return struct.get(m_unReputationScore$LAYOUT, m_unReputationScore$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32 m_unReputationScore
     * }
     */
    public static void m_unReputationScore(MemorySegment struct, int fieldValue) {
        struct.set(m_unReputationScore$LAYOUT, m_unReputationScore$OFFSET, fieldValue);
    }

    private static final OfBoolean m_bBanned$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("m_bBanned"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool m_bBanned
     * }
     */
    public static final OfBoolean m_bBanned$layout() {
        return m_bBanned$LAYOUT;
    }

    private static final long m_bBanned$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool m_bBanned
     * }
     */
    public static final long m_bBanned$offset() {
        return m_bBanned$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool m_bBanned
     * }
     */
    public static boolean m_bBanned(MemorySegment struct) {
        return struct.get(m_bBanned$LAYOUT, m_bBanned$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool m_bBanned
     * }
     */
    public static void m_bBanned(MemorySegment struct, boolean fieldValue) {
        struct.set(m_bBanned$LAYOUT, m_bBanned$OFFSET, fieldValue);
    }

    private static final OfInt m_unBannedIP$LAYOUT = (OfInt)$LAYOUT.select(groupElement("m_unBannedIP"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32 m_unBannedIP
     * }
     */
    public static final OfInt m_unBannedIP$layout() {
        return m_unBannedIP$LAYOUT;
    }

    private static final long m_unBannedIP$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32 m_unBannedIP
     * }
     */
    public static final long m_unBannedIP$offset() {
        return m_unBannedIP$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32 m_unBannedIP
     * }
     */
    public static int m_unBannedIP(MemorySegment struct) {
        return struct.get(m_unBannedIP$LAYOUT, m_unBannedIP$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32 m_unBannedIP
     * }
     */
    public static void m_unBannedIP(MemorySegment struct, int fieldValue) {
        struct.set(m_unBannedIP$LAYOUT, m_unBannedIP$OFFSET, fieldValue);
    }

    private static final OfShort m_usBannedPort$LAYOUT = (OfShort)$LAYOUT.select(groupElement("m_usBannedPort"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint16 m_usBannedPort
     * }
     */
    public static final OfShort m_usBannedPort$layout() {
        return m_usBannedPort$LAYOUT;
    }

    private static final long m_usBannedPort$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint16 m_usBannedPort
     * }
     */
    public static final long m_usBannedPort$offset() {
        return m_usBannedPort$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint16 m_usBannedPort
     * }
     */
    public static short m_usBannedPort(MemorySegment struct) {
        return struct.get(m_usBannedPort$LAYOUT, m_usBannedPort$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint16 m_usBannedPort
     * }
     */
    public static void m_usBannedPort(MemorySegment struct, short fieldValue) {
        struct.set(m_usBannedPort$LAYOUT, m_usBannedPort$OFFSET, fieldValue);
    }

    private static final OfLong m_ulBannedGameID$LAYOUT = (OfLong)$LAYOUT.select(groupElement("m_ulBannedGameID"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64 m_ulBannedGameID
     * }
     */
    public static final OfLong m_ulBannedGameID$layout() {
        return m_ulBannedGameID$LAYOUT;
    }

    private static final long m_ulBannedGameID$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64 m_ulBannedGameID
     * }
     */
    public static final long m_ulBannedGameID$offset() {
        return m_ulBannedGameID$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64 m_ulBannedGameID
     * }
     */
    public static long m_ulBannedGameID(MemorySegment struct) {
        return struct.get(m_ulBannedGameID$LAYOUT, m_ulBannedGameID$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64 m_ulBannedGameID
     * }
     */
    public static void m_ulBannedGameID(MemorySegment struct, long fieldValue) {
        struct.set(m_ulBannedGameID$LAYOUT, m_ulBannedGameID$OFFSET, fieldValue);
    }

    private static final OfInt m_unBanExpires$LAYOUT = (OfInt)$LAYOUT.select(groupElement("m_unBanExpires"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32 m_unBanExpires
     * }
     */
    public static final OfInt m_unBanExpires$layout() {
        return m_unBanExpires$LAYOUT;
    }

    private static final long m_unBanExpires$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32 m_unBanExpires
     * }
     */
    public static final long m_unBanExpires$offset() {
        return m_unBanExpires$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32 m_unBanExpires
     * }
     */
    public static int m_unBanExpires(MemorySegment struct) {
        return struct.get(m_unBanExpires$LAYOUT, m_unBanExpires$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32 m_unBanExpires
     * }
     */
    public static void m_unBanExpires(MemorySegment struct, int fieldValue) {
        struct.set(m_unBanExpires$LAYOUT, m_unBanExpires$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

